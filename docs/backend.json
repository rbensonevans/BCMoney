
{
  "entities": {
    "UserProfile": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserProfile",
      "type": "object",
      "description": "Represents a user's profile information.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user profile."
        },
        "firstName": {
          "type": "string",
          "description": "User's first name."
        },
        "middleName": {
          "type": "string",
          "description": "User's middle name."
        },
        "lastName": {
          "type": "string",
          "description": "User's last name."
        },
        "address": {
          "type": "string",
          "description": "User's physical address."
        },
        "phoneNumber": {
          "type": "string",
          "description": "User's phone number."
        },
        "email": {
          "type": "string",
          "description": "User's email address.",
          "format": "email"
        },
        "photoUrl": {
          "type": "string",
          "description": "URL of the user's profile photo.",
          "format": "uri"
        },
        "watchlist": {
          "type": "array",
          "description": "List of token IDs the user is tracking.",
          "items": {
            "type": "string"
          }
        },
        "ownedTokens": {
          "type": "array",
          "description": "List of token IDs the user has added to their collection.",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "firstName",
        "lastName",
        "email"
      ]
    },
    "Account": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Account",
      "type": "object",
      "description": "Represents a user's account, linking it to a unique name and Ethereum address.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the account."
        },
        "userProfileId": {
          "type": "string",
          "description": "Reference to UserProfile. (Relationship: UserProfile 1:1 Account)"
        },
        "uniqueName": {
          "type": "string",
          "description": "A unique name chosen by the user for their account."
        },
        "ethereumAddress": {
          "type": "string",
          "description": "The user's Ethereum public address."
        },
        "balance": {
          "type": "number",
          "description": "The current balance of the account."
        }
      },
      "required": [
        "id",
        "userProfileId",
        "uniqueName",
        "ethereumAddress",
        "balance"
      ]
    },
    "Transaction": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Transaction",
      "type": "object",
      "description": "Represents a financial transaction.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the transaction."
        },
        "accountId": {
          "type": "string",
          "description": "Reference to Account. (Relationship: Account 1:N Transaction)"
        },
        "transactionDate": {
          "type": "string",
          "description": "Date and time of the transaction.",
          "format": "date-time"
        },
        "amount": {
          "type": "number",
          "description": "The amount of the transaction."
        },
        "transactionType": {
          "type": "string",
          "description": "The type of transaction, e.g., 'deposit', 'withdrawal', 'send'."
        },
        "recipientAccountId": {
          "type": "string",
          "description": "Reference to recipient Account (if applicable). (Relationship: Account 1:N Transaction, optional recipient)",
          "format": "uuid"
        }
      },
      "required": [
        "id",
        "accountId",
        "transactionDate",
        "amount",
        "transactionType"
      ]
    },
    "Recipient": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Recipient",
      "type": "object",
      "description": "Represents a recipient in one of the user's lists (Family, Friends, General).",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the recipient."
        },
        "userProfileId": {
          "type": "string",
          "description": "Reference to UserProfile. (Relationship: UserProfile 1:N Recipient)"
        },
        "name": {
          "type": "string",
          "description": "Name of the recipient."
        },
        "ethereumAddress": {
          "type": "string",
          "description": "Ethereum address of the recipient."
        },
        "listType": {
          "type": "string",
          "description": "The list type the recipient belongs to: 'Family', 'Friends', or 'General'."
        }
      },
      "required": [
        "id",
        "userProfileId",
        "name",
        "ethereumAddress",
        "listType"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/user_profiles/{userProfileId}",
        "definition": {
          "entityName": "UserProfile",
          "schema": {
            "$ref": "#/backend/entities/UserProfile"
          },
          "description": "Stores user profile information. The 'userProfileId' MUST match the Firebase auth 'uid'.",
          "params": [
            {
              "name": "userProfileId",
              "description": "The unique ID of the user profile, matching the Firebase auth 'uid'."
            }
          ]
        }
      },
      {
        "path": "/accounts/{accountId}",
        "definition": {
          "entityName": "Account",
          "schema": {
            "$ref": "#/backend/entities/Account"
          },
          "description": "Stores user account information. Includes denormalized 'userProfileId' for authorization independence.",
          "params": [
            {
              "name": "accountId",
              "description": "The unique ID of the user account."
            }
          ]
        }
      },
      {
        "path": "/accounts/{accountId}/transactions/{transactionId}",
        "definition": {
          "entityName": "Transaction",
          "schema": {
            "$ref": "#/backend/entities/Transaction"
          },
          "description": "Stores transaction history for a specific account. Includes denormalized 'accountId' for authorization independence.",
          "params": [
            {
              "name": "accountId",
              "description": "The unique ID of the user account."
            },
            {
              "name": "transactionId",
              "description": "The unique ID of the transaction."
            }
          ]
        }
      },
      {
        "path": "/user_profiles/{userProfileId}/recipients/{recipientId}",
        "definition": {
          "entityName": "Recipient",
          "schema": {
            "$ref": "#/backend/entities/Recipient"
          },
          "description": "Stores recipient information for a specific user. Includes denormalized 'userProfileId' for authorization independence.",
          "params": [
            {
              "name": "userProfileId",
              "description": "The unique ID of the user profile."
            },
            {
              "name": "recipientId",
              "description": "The unique ID of the recipient."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to ensure security, scalability, and ease of debugging, following the principles of Authorization Independence, Clarity of Intent, DBAC, and QAPs. It uses Structural Segregation to ensure homogeneous security postures and Access Modeling to standardize authorization patterns.\n\n1.  **User Profiles:** User profiles are stored in a collection `/user_profiles/{userProfileId}`. This allows direct access to profile information based on the `userProfileId`. Since UserProfile is considered private data and to achieve Authorization Independence, access is path-based using the `request.auth.uid`. Because of the 1:1 relationship with Account, `userProfileId` is the same as `request.auth.uid`.\n2.  **Accounts:** Accounts are stored in `/accounts/{accountId}`. This collection stores data related to a specific account. The `userProfileId` is denormalized in the Account document. This ensures authorization independence as the rule for the account does not rely on a `get()` call to the UserProfile.\n3.  **Transactions:** Transactions are stored as a subcollection of accounts at `/accounts/{accountId}/transactions/{transactionId}`. This allows efficient querying of transactions associated with a specific account. `accountId` is denormalized in the Transaction document. This maintains Authorization Independence because the rule can directly verify the account without needing parent document data.\n4.  **Recipients:** Recipients are stored as a subcollection of user profiles at `/user_profiles/{userProfileId}/recipients/{recipientId}`. This allows users to manage their recipients list. `userProfileId` is denormalized in the Recipient document to enforce authorization independence, meaning that the rules do not need to fetch the parent `user_profile` document to enforce recipient level authorization.\n\nThis structure ensures Authorization Independence by denormalizing authorization attributes (e.g., `userProfileId` in Account, Transaction, and Recipient documents). This avoids the need for `get()` calls in security rules, simplifying the rules and enabling atomic operations. Structural Segregation is achieved by storing different data types (profiles, accounts, transactions, recipients) in separate collections or subcollections, each with its specific security requirements. Access Modeling leverages path-based ownership (`/user_profiles/{userProfileId}`) and subcollections (`/accounts/{accountId}/transactions/{transactionId}`) to clearly define ownership and access rights."
  }
}
